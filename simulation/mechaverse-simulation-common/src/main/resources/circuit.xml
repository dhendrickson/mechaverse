<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<circuit xmlns="http://www.mechaverse.org/circuit/model" width="16" height="16" iterationsPerUpdate="200">

  <element-type id="register">
    <output id="1">
      <expression><![CDATA[({output1} & ~{input1}) | ({input2} & {input1})]]></expression>
    </output>
  </element-type>

  <!-- An element that outputs a circuit input. -->
  <element-type id="input">
    <output id="1">
      <param id="idx" />
      <expression><![CDATA[circuitInput[{idx} % circuitInputLength]]]></expression>
    </output>
  </element-type>

  <!-- An element for routing data from one part of the circuit to another. -->
  <element-type id="interplaneRouting">
    <output id="1">
      <expression><![CDATA[({input1} << 1)]]></expression>
    </output>
  </element-type>

  <!-- An element for routing data from one part of the circuit to another. -->
  <element-type id="routing3in3out">
    <output id="1">
      <param id="input2Mask" />
      <param id="input3Mask" />
      <expression><![CDATA[({input2} & {input2Mask}) | ({input3} & {input3Mask})]]></expression>
    </output>
    <output id="2">
      <param id="input1Mask" />
      <param id="input3Mask" />
      <expression><![CDATA[({input1} & {input1Mask}) | ({input3} & {input3Mask})]]></expression>
    </output>
    <output id="3">
      <param id="input1Mask" />
      <param id="input2Mask" />
      <expression><![CDATA[({input1} & {input1Mask}) | ({input2} & {input2Mask})]]></expression>
    </output>
  </element-type>

  <element-type id="boolean3in3out">
    <output id="{1,2,3}">
      <param id="invert" />
      <!-- Term 1 -->
      <param id="t1InvertInput1" />
      <param id="t1MaskInput1" />
      <param id="t1InvertInput2" />
      <param id="t1MaskInput2" />
      <param id="t1InvertInput3" />
      <param id="t1MaskInput3" />
      <!-- Term 2 -->
      <param id="t2InvertInput1" />
      <param id="t2MaskInput1" />
      <param id="t2InvertInput2" />
      <param id="t2MaskInput2" />
      <param id="t2InvertInput3" />
      <param id="t2MaskInput3" />
      <!-- Term 3 -->
      <param id="t3InvertInput1" />
      <param id="t3MaskInput1" />
      <param id="t3InvertInput2" />
      <param id="t3MaskInput2" />
      <param id="t3InvertInput3" />
      <param id="t3MaskInput3" />
      <!-- Term 4 -->
      <param id="t4InvertInput1" />
      <param id="t4MaskInput1" />
      <param id="t4InvertInput2" />
      <param id="t4MaskInput2" />
      <param id="t4InvertInput3" />
      <param id="t4MaskInput3" />
      <expression><![CDATA[
    ( (({input1}^{t1InvertInput1})&{t1MaskInput1}) | (({input2}^{t1InvertInput2})&{t1MaskInput2}) | (({input3}^{t1InvertInput3})&{t1MaskInput3})
    & (({input1}^{t2InvertInput1})&{t2MaskInput1}) | (({input2}^{t2InvertInput2})&{t2MaskInput2}) | (({input3}^{t2InvertInput3})&{t2MaskInput3})
    & (({input1}^{t3InvertInput1})&{t3MaskInput1}) | (({input2}^{t3InvertInput2})&{t3MaskInput2}) | (({input3}^{t3InvertInput3})&{t3MaskInput3})
    & (({input1}^{t4InvertInput1})&{t4MaskInput1}) | (({input2}^{t4InvertInput2})&{t4MaskInput2}) | (({input3}^{t4InvertInput3})&{t4MaskInput3})
    ) ^ {invert}
      ]]></expression>
    </output>
  </element-type>

  <logical-unit neighborConnections="3">
    <row>
      <element type="routing3in3out" />
      <element type="routing3in3out" />
      <element type="routing3in3out" />
      <element type="routing3in3out" />
    </row>
    <row>
      <element type="input" />
      <element type="boolean3in3out" />
      <element type="input" />
      <element type="boolean3in3out" outputs="{1}" />
    </row>
    <row>
      <element type="routing3in3out" />
      <element type="boolean3in3out" />
      <element type="input" />
      <element type="boolean3in3out" outputs="{1}" />
    </row>
    <row>
      <element type="routing3in3out" />
      <element type="routing3in3out" />
      <element type="routing3in3out" />
      <element type="routing3in3out" />
    </row>
  </logical-unit>
</circuit>